/* ================================================================================================================================================== *
 * LIST of FUNCTIONS:                                                                                                                                 *
 * ------------------                                                                                                                                 *
 *  - FUNCTION GW_UPDATE_ITM_DESCRIPTION_TO_EE      : MODIFIES item descriptions to fit EE description format.                         => line #  15  *
 *  - FUNCTION GW_WRITE_EE_ITM_DESCRIPTIONS         : WRITES item descriptions in ITM files according to the game (classical or EE).   => line #  54  *
 *  - MACRO GW_ADJUST_TOOLTIP                       : ADDS new columns in tooltip.2da file if needed.                                  => line # 103  *
 *  - MACRO GW_READ_COL_TOOLTIP                     : READS tooltip.2da file number of columns.                                        => line # 137  *
 *  - FUNCTION GW_ADD_ITEM_TOOLTIPS                 : ADDS a new line in tooltip.2da. file.                                            => line # 153  *
 *  - FUNCTION GW_ALTER_ITEM_ALTER_HEADER_FLAGS     : ALTERS itm extender headers new EE (or ToBEx) flags.                             => line # 198  *
 *  - FUNCTION GW_ITEM_RESTRICT_USABILITY_EE        : DEFINES special item usability restrictions (EE games).                          => line # 324  *
 *  - FUNCTION GW_FIND_DLG_RESPONSE_STRING          : LOOKS for state and transition numbers matching a strref in a dialog.            => line # 428  *
 * ================================================================================================================================================== */

/* =========================================================================================================== *
 *  FUNCTION GW_UPDATE_ITM_DESCRIPTION_TO_EE: AJUSTE la DESCRIPTION des OBJETS au format Enhanced Edition.     *
 * ----------------------------------------------------------------------------------------------------------- *
 *  Reads variable GW_desc_to_update (@nn or #nnn) in .tra file, alters it to fit EE description format,       *
 *  then saves it as variable GW_desc_updated.                                                                 *
 * =========================================================================================================== *
 *  FUNCTION GW_WRITE_EE_ITM_DESCRIPTIONS: ÉCRIT les DESCRIPTIONS des OBJETS au format Enhanced Edition.       *
 * ----------------------------------------------------------------------------------------------------------- *
 *  Reads variables GW_desc_to_update and GW_undesc_to_update (@nnn or #nnn) in .tra file, alters them to fit  *
 *  EE description format if needed, then updates .ITM file.                                                   *
 * =========================================================================================================== */

DEFINE_PATCH_FUNCTION ~GW_UPDATE_ITM_DESCRIPTION_TO_EE~ 
	STR_VAR GW_desc_to_update = ~~	// reference in format @123 or #123
	RET		GW_desc_updated			// returns modified text
BEGIN

	INNER_ACTION BEGIN
		ACTION_IF (~%GW_desc_to_update%~ STRING_COMPARE_REGEXP ~^[@#]-?[0-9]+$~ == 0) BEGIN
			<<<<<<<< .../inlined/GW_%GW_desc_to_update%.tpp
OUTER_SPRINT GW_desc_updated 
>>>>>>>>
			SILENT
			COPY - ~.../inlined/GW_%GW_desc_to_update%.tpp~ ~.../inlined/GW_%GW_desc_to_update%.tpp~
				INSERT_BYTES SOURCE_SIZE (STRING_LENGTH ~%GW_desc_to_update%~)
				WRITE_ASCIIE SOURCE_SIZE ~%GW_desc_to_update%~
			INCLUDE ~.../inlined/GW_%GW_desc_to_update%.tpp~
			OUTER_SPRINT usab @9001		// ~[Uu]niquement[ %tab%]+[Uu]tilisable[ %tab%]+[Pp]ar[ %tab%]*:~ = ~[Oo]nly[ %tab%]+[Uu]sable[ %tab%]+[Bb]y[ %tab%]*:~
			OUTER_SPRINT unus @9002		// ~\([Nn]on[ %tab%]+\|[Ii]n\)[Uu]tilisable[ %tab%]+[Pp]ar[ %tab%]*:~ = ~\(Not[ %tab%]+\|Un\)[Uu]sable[ %tab%]+[Bb]y[ %tab%]*:~
			OUTER_PATCH_SAVE GW_desc_updated ~%GW_desc_updated%~ BEGIN	// Suppression de toutes les références aux classes et aux kits pouvant ou pas utiliser l'objet. - Removes all classes and kits (un-)usability flags.
				REPLACE_TEXTUALLY ~\(\([%LNL%%MNL%%WNL%][ %TAB%]*\(%usab%\|%unus%\)[ %TAB%]*\)\(\([%LNL%%MNL%%WNL%].*\)*\)?\)~  ~~
			END
		END ELSE BEGIN
			OUTER_SPRINT GW_desc_updated ~none~
		END
	END	// of INNER_ACTION

END		// of DEFINE_PATCH_FUNCTION


DEFINE_PATCH_FUNCTION ~GW_WRITE_EE_ITM_DESCRIPTIONS~ 
	STR_VAR GW_desc_to_update	= ~~	// reference in format @123 or #123
			GW_undesc_to_update = ~~	// reference in format @123 or #123
BEGIN

	PATCH_IF (GAME_IS ~bgee bg2ee eet iwdee~) OR GAME_INCLUDES ~sod~ BEGIN
		SPRINT GWdesc "none"
		SPRINT GWundesc "none"
		PATCH_IF ("%GW_desc_to_update%" STRING_COMPARE_REGEXP ~^[@#]-?[0-9]+$~ = 0) AND ("%GW_desc_to_update%" STR_CMP ~~) BEGIN
			LPF ~GW_UPDATE_ITM_DESCRIPTION_TO_EE~ STR_VAR GW_desc_to_update = EVAL "%GW_desc_to_update%" RET GWdesc = GW_desc_updated END
		END ELSE BEGIN
			SPRINT GWdesc ~none~
		END
		PATCH_IF ("%GW_undesc_to_update%" STRING_COMPARE_REGEXP ~^[@#]-?[0-9]+$~ = 0) AND ("%GW_undesc_to_update%" STR_CMP ~~) BEGIN
			LPF ~GW_UPDATE_ITM_DESCRIPTION_TO_EE~ STR_VAR GW_desc_to_update = EVAL "%GW_undesc_to_update%" RET GWundesc = GW_desc_updated END
		END ELSE BEGIN
			SPRINT GWundesc ~none~
		END
		PATCH_IF ("%GWdesc%" STR_CMP "none")	BEGIN SAY_EVALUATED DESC ~%GWdesc%~ END
		PATCH_IF ("%GWundesc%" STR_CMP "none")	BEGIN SAY_EVALUATED UNIDENTIFIED_DESC ~%GWundesc%~ END 

	END ELSE BEGIN		// BG2 ou BGT
		PATCH_IF ("%GW_desc_to_update%" STRING_COMPARE_REGEXP ~^[@#]-?[0-9]+$~ = 0) AND ("%GW_desc_to_update%" STR_CMP ~~) BEGIN
			INNER_PATCH_SAVE GWdesc ~%GW_desc_to_update%~ BEGIN		// Suppression du premier caractère (@ ou #) - Removes 1st character (@ or #).
				REPLACE_TEXTUALLY ~^[@#]~  ~~
			END
			PATCH_IF ("%GW_desc_to_update%" STRING_COMPARE_REGEXP ~^[@]-?[0-9]+$~ = 0) BEGIN
				WRITE_LONG 0x54 RESOLVE_STR_REF ((AT %GWdesc%))
			END ELSE BEGIN											// inutile d'employer PATCH_IF ("%GW_desc_to_update%" STRING_COMPARE_REGEXP ~^[#]-?[0-9]+$~ = 0) BEGIN
				WRITE_LONG 0x54 %GWdesc%
			END
		END
		PATCH_IF ("%GW_undesc_to_update%" STRING_COMPARE_REGEXP ~^[@#]-?[0-9]+$~ = 0) AND ("%GW_undesc_to_update%" STR_CMP ~~) BEGIN
			INNER_PATCH_SAVE GWundesc ~%GW_undesc_to_update%~ BEGIN	// Suppression du premier caractère (@ ou #) - Removes 1st character (@ or #).
				REPLACE_TEXTUALLY ~^[@#]~  ~~
			END
			PATCH_IF ("%GW_undesc_to_update%" STRING_COMPARE_REGEXP ~^[@]-?[0-9]+$~ = 0) BEGIN
				WRITE_LONG 0x50 RESOLVE_STR_REF ((AT %GWundesc%))
			END ELSE BEGIN
				WRITE_LONG 0x50 %GWundesc%
			END
		END

	END	// of PATCH_IF (ENGINE_IS ~bgee bg2ee eet~) OR GAME_INCLUDES ~sod~

END		// of DEFINE_PATCH_FUNCTION


/* ============================================================================== *
 *  MACRO GW_ADJUST_COL_TOOLTIP: ADDS new columns in tooltip.2da file if needed.  *
 * ------------------------------------------------------------------------------ *
 *  CODE borrowed and adapted from Miloch's one.                                  *
 * ============================================================================== */

DEFINE_ACTION_MACRO ~GW_ADJUST_COL_TOOLTIP~ BEGIN

	COPY_EXISTING ~tooltip.2da~ ~override~
		COUNT_2DA_COLS cl
		COUNT_2DA_ROWS 1 rw
		SPRINT cz ~~
		SPRINT rx ~       ~ // 7
		SPRINT ry ~-1~
		SPRINT rz ~~
		PATCH_IF cl < 5 BEGIN
			SPRINT rz ~$ $ 4~
			FOR (i = 0 ; i < (rw - 3) ; ++i) BEGIN	// Cycle through rows
				SPRINT rz ~%rz%~ ^ ~%rx%~ ^ ~%ry%~
			END
		END ELSE BEGIN
			FOR (j = 9 ; j < (cl - 1) ; ++j) BEGIN	// Cycle through columns
				SPRINT cz ~%cz%~ ^ ~%rx%~ ^ ~%ry%~
			END
		END
	BUT_ONLY

	ACTION_IF cl < 10 BEGIN
		APPEND_COL ~tooltip.2da~ ~%rz%~
	END

END	// of DEFINE_ACTION_MACRO


/* ====================================================================== *
 *  MACRO GW_READ_COL_TOOLTIP: READS tooltip.2da file number of columns.  *
 * ---------------------------------------------------------------------- *
 *  RETURNS cols_tooltip value (used by GW_ADD_ITEM_TOOLTIPS function).   *
 * ====================================================================== */

DEFINE_ACTION_MACRO ~GW_READ_COL_TOOLTIP~ BEGIN

	COPY_EXISTING - ~tooltip.2da~ ~override~
		COUNT_2DA_COLS cols_tooltip
		COUNT_2DA_ROWS 1 rows_tooltip

END


/* ========================================================================= *
 *  FUNCTION GW_ADD_ITEM_TOOLTIPS: ADDS a new line in tooltip.2da. file.     *
 * ------------------------------------------------------------------------- *
 *  PARSES %GW_tooltips% string chain and adds a new line in tooltip.2da.    *
 * ========================================================================= */

DEFINE_ACTION_FUNCTION ~GW_ADD_ITEM_TOOLTIPS~
	STR_VAR	GW_objet	= ~N~	// item code: ~sw1h01~
			GW_tooltips	= ~~	// tooltips stringref list: ~@123 @124 6620~, accepts combination of tra refs and strrefs for as many abilities as you need to specify
BEGIN

	ACTION_IF ("%GW_objet%" STRING_COMPARE_CASE "N") BEGIN
		ACTION_TO_UPPER GW_objet

	// Generates a row to be added to tooltip.2da
		OUTER_TEXT_SPRINT new_row ~%GW_objet%~
		OUTER_PATCH ~ %GW_tooltips%~ BEGIN	// Extracts each tooltip from GW_tooltips string
			COUNT_REGEXP_INSTANCES ~[ %TAB%]+\(@?-?[0-9]+\)~ num_tooltips
			REPLACE_EVALUATE ~[ %TAB%]+\(@?-?[0-9]+\)~ BEGIN
				PATCH_IF ((~%MATCH1%~ STRING_MATCHES_REGEXP ~@-?[0-9]+~) = 0) BEGIN // tra ref
					INNER_PATCH_SAVE GW_tooltip ~%MATCH1%~ BEGIN
						REPLACE_TEXTUALLY ~[@]~  ~~
					END
					SET GW_tool = RESOLVE_STR_REF ( (AT GW_tooltip) )
					TEXT_SPRINT new_row ~%new_row% %GW_tool%~ 	// Adds to the new row
				END ELSE BEGIN // strref
					TEXT_SPRINT new_row ~%new_row% %MATCH1%~ 	// Adds to the new row
				END
				TEXT_SPRINT empty_cols ~~
			END ~~
		END

		ACTION_IF num_tooltips < (cols_tooltip -1) BEGIN
			OUTER_FOR (i = (cols_tooltip - 1) ; i > num_tooltips ; --i) BEGIN	// Generates -1 entries for the number of missing columns
				OUTER_TEXT_SPRINT empty_cols ~%empty_cols% -1~
			END
		END

		OUTER_TEXT_SPRINT new_row ~%new_row%%empty_cols%~
		APPEND ~tooltip.2da~ ~%new_row%~ UNLESS ~^%GW_objet%~

	END

END	// of DEFINE_ACTION_FUNCTION


/* ====================================================================================================================================== *
 *  FUNCTION GW_ALTER_ITEM_ALTER_HEADER_FLAGS: ALTERS itm extender headers new EE (or ToBEx) flags.                                       *
 * -------------------------------------------------------------------------------------------------------------------------------------- *
 *  INTEGER VARIABLES :                                                                                                                   *
 *    - type                : header type (1 = Melee - 2 = Range - 3 = Magical - 4) Launcher - default = "-1", all).                      *
 *    - header              : modifies specified header (default = 0, matches all headers, used with type = -1).                          *
 *    - flag_strength       : adds strength bonus, set in bit0  (1 = adds - 0 = remove - default = "-1", no change).                      *
 *    - flag_break          : breakable, set in bit1 (1 = adds - 0 = remove - default = "-1", no change).                                 *
 *    - flag_breaksanctuary : breaks sanctuary (EE), set in bit9 (1 = adds - 0 = remove - default = "-1", no change).                     *
 *    - flag_hostile        : hostile, set in bit10 (1 = adds - 0 = remove - default = "-1", no change).                                  *
 *    - flag_recharge       : recharge after resting, set in bit11   (1 = adds - 0 = remove - default = "-1", no change).                 *
 *    - flag_bypass         : bypass armor, set in bit16 (1 = adds - 0 = remove - default = "-1", no change).                             *
 *    - flag_keenedge       : keen edge, set in bit17 (1 = adds - 0 = remove - default = "-1", no change).                                *
 *    - flag_backstab       : can backstab (EE and ToBEx), set in bit25  (1 = adds - 0 = remove - default = "-1", no change).             *
 *    - flag_noinvisible    : cannot target invisible (EE and ToBEx), set in bit26  (1 = adds - 0 = remove - default = "-1", no change).  *
 * ====================================================================================================================================== */

DEFINE_PATCH_FUNCTION ~GW_ALTER_ITEM_ALTER_HEADER_FLAGS~
	INT_VAR type				= "-1" // -1 is all headers, otherwise use value here
			header				= 0    // 0 matches all headers, otherwise just modify specified header - use with type = -1
			// flag_vars affect flags starting at 0x26; 0 means removes flag, 1 means adds flag, -1 no change
			flag_strength		= "-1" // adds strength bonus, bit0
			flag_break			= "-1" // breakable, bit1
//			flag_str_damage		= "-1" // damage damage bonus, ee, bit2
//			flag_str_to_hit		= "-1" // thac0 strength bonus, ee, bit3
			flag_breaksanctuary	= "-1" // breaks sanctuary, ee, bit9
			flag_hostile		= "-1" // hostile, bit10
			flag_recharge		= "-1" // recharge after resting, bit11
			flag_bypass			= "-1" // bypass armor, bit16
			flag_keenedge		= "-1" // keen edge, bit17
			flag_backstab		= "-1" // tobex and ee only, can backstab, bit25
			flag_noinvisible	= "-1" // tobex and ee only, cannot target invisible, bit26
BEGIN

	READ_LONG  0x64 "abil_off"
	READ_SHORT 0x68 "abil_num"
//PATCH_PRINT "DEBUGGING CONTROL abil_off = %abil_off% - abil_num = %abil_num%"
	PATCH_IF (header = 0) BEGIN
		SET loop_start = 0
		SET loop_end = abil_num
	END ELSE BEGIN
		SET loop_start = (header - 1)
		SET loop_end = header
	END
//PATCH_PRINT "DEBUGGING CONTROL loop_start = %loop_start% - loop_end = %loop_end%"

	FOR (i = loop_start ; i < loop_end ; ++i) BEGIN
		SET offset = abil_off + (i * 0x38)
		READ_BYTE offset abil_type
		PATCH_IF ((type < 0) OR (abil_type = type)) BEGIN
			READ_LONG (offset + 0x26) flags
			SET flags_off = (offset + 0x26)
//PATCH_PRINT "DEBUGGING CONTROL i = %i% ==> offset = %offset% - abil_type = %abil_type% - flags_off = %flags_off% - flags = %flags%"
			PATCH_IF (flag_strength = 0) AND ((flags & BIT0) = BIT0) BEGIN
				WRITE_LONG flags_off (THIS & `BIT0)
			END
			PATCH_IF (flag_strength = 1) AND ((flags & BIT0) = 0) BEGIN	// (THIS BOR BIT0)
				WRITE_LONG flags_off (THIS | BIT0)
			END
			PATCH_IF (flag_break = 0) AND ((flags & BIT1) = BIT1) BEGIN
				WRITE_LONG flags_off (THIS & `BIT1)
			END
			PATCH_IF (flag_break = 1) AND ((flags & BIT1) = 0) BEGIN
				WRITE_LONG flags_off (THIS | BIT1)
			END
/*			PATCH_IF (flag_str_damage  = 0) AND ((flags & BIT2) = BIT2) BEGIN
				WRITE_LONG (flags_off) THIS & `BIT2)
			END
			PATCH_IF (flag_str_damage  = 1) AND ((flags & BIT2) = 0) BEGIN
				WRITE_LONG flags_off (THIS | BIT2)
			END
			PATCH_IF (flag_str_to_hit = 0) AND ((flags & BIT3) = BIT3) BEGIN
				WRITE_LONG flags_off (THIS & `BIT3)
			END
			PATCH_IF (flag_str_to_hit = 1) AND ((flags & BIT3) = 0) BEGIN
				WRITE_LONG flags_off (THIS | BIT3)
			END
*/			PATCH_IF (flag_breaksanctuary = 0) AND ((flags & BIT9) = BIT9) BEGIN
				WRITE_LONG flags_off (THIS & `BIT9)
			END
			PATCH_IF (flag_breaksanctuary = 1) AND ((flags & BIT9) = 0) BEGIN
				WRITE_LONG flags_off (THIS | BIT9)
			END
			PATCH_IF (flag_hostile = 0) AND ((flags & BIT10) = BIT10) BEGIN
				WRITE_LONG flags_off (THIS & `BIT10)
			END
			PATCH_IF (flag_hostile = 1) AND ((flags & BIT10) = 0) BEGIN
				WRITE_LONG flags_off (THIS | BIT10)
			END
			PATCH_IF (flag_recharge = 0) AND ((flags & BIT11) = BIT11) BEGIN
				WRITE_LONG flags_off (THIS & `BIT11)
			END
			PATCH_IF (flag_recharge = 1) AND ((flags & BIT11) = 0) BEGIN
				WRITE_LONG flags_off (THIS | BIT11)
			END
			PATCH_IF (flag_bypass = 0) AND ((flags & BIT16) = BIT16) BEGIN
				WRITE_LONG flags_off (THIS & `BIT16)
			END
			PATCH_IF (flag_bypass = 1) AND ((flags & BIT16) = 0) BEGIN
				WRITE_LONG flags_off (THIS | BIT16)
			END
			PATCH_IF (flag_keenedge = 0) AND ((flags & BIT17) = BIT17) BEGIN
				WRITE_LONG flags_off (THIS & `BIT17)
			END
			PATCH_IF (flag_keenedge = 1) AND ((flags & BIT17) = 0) BEGIN
				WRITE_LONG flags_off (THIS | BIT17)
			END
			PATCH_IF (flag_backstab = 0) AND ((flags & BIT25) = BIT25) BEGIN
				WRITE_LONG flags_off (THIS & `BIT25)
			END
			PATCH_IF (flag_backstab = 1) AND ((flags & BIT25) = 0) BEGIN
				WRITE_LONG flags_off (THIS | BIT25)
			END
			PATCH_IF (flag_noinvisible = 0) AND ((flags & BIT26) = BIT26) BEGIN
				WRITE_LONG flags_off (THIS & `BIT26)
			END
			PATCH_IF (flag_noinvisible = 1) AND ((flags & BIT26) = 0) BEGIN
				WRITE_LONG flags_off (THIS | BIT26)
			END
		END

	END

END	// of DEFINE_PATCH_FUNCTION


/* ================================================================================================================= *
 *  FUNCTION GW_ITEM_RESTRICT_USABILITY_EE: DEFINES special item usability restrictions (EE games)                   *
 *                                          INTERDIT L'UTILISATION D'UN OBJET à un type de créature dans BG2EE.      *
 * ----------------------------------------------------------------------------------------------------------------- *
 *  #319 Usability: Item Usability : This effect restricts the item to creature(s) matching the object identifiers.  *
 *  The string to display in the description note is set in 0x2c.                                                    *
 * ================================================================================================================= */

DEFINE_PATCH_FUNCTION ~GW_ITEM_RESTRICT_USABILITY_EE~ 
    INT_VAR GW_shaman   = 0     // Automatic Druid restriction removal, now handled with op#319
    STR_VAR GW_restrict = ""    // HUMAN, MALE, CAVALIER... Or string defining Actor's name, or scripting name (8 maximum length).
            GW_power    = 0     // When GW_power is set to 1, this effect restricts the item to creature(s) matching the object identifiers. When GW_power is set to 0, creature(s) matching the object identifiers cannot use the item. The string to display when an invalid creature attempts to use the item is held in GW_mess319 (0x2c).
            GW_kind     = ""    // IDS file : EA, General, Race, class, Specific, Gender, Align, Kit. OR Name (Actor's name), script_name (Actor's scripting name).
            GW_mess319  = 0     // Description note (special field)
BEGIN

	PATCH_IF (GW_shaman) BEGIN

		WRITE_LONG 0x1e (THIS BAND BNOT BIT30)	// removes Druid exclusion flag
		LPF ADD_ITEM_EQEFFECT INT_VAR insert_point = "-1" opcode = 319 target = 1 timing = 2 parameter1 = 11 parameter2 = 5 power = 0 special = 1080 END	// Restrict Item (Usability: Item Usability) : 11 Druid - 5 Class.ids

	END ELSE BEGIN

		SET GW_param2 = 0
		SET GW_special319 = 0
		SPRINT GW_resource319 ""

		PATCH_IF ("%GW_restrict%" STR_CMP ~~) AND ("%GW_kind%" STR_CMP ~~) BEGIN 
		// IDS files case : EA, General, Race, class, Specific, Gender, Align, Kit.
		// --------------
			PATCH_IF ("%GW_kind%" STRING_COMPARE_CASE ~NAME~) AND ("%GW_kind%" STRING_COMPARE_CASE ~SCRIPT_NAME~) BEGIN 
				PATCH_IF FILE_EXISTS_IN_GAME ~%GW_kind%.ids~ BEGIN
					SET GW_param1 = IDS_OF_SYMBOL (~%GW_kind%~ ~%GW_restrict%~)
					PATCH_IF (GW_param1 != "-1") BEGIN				// IDS_OF_SYMBOL returns -1 if GW_restrict is not associated in GW_kind.ids.
						PATCH_MATCH ~%GW_kind%~ WITH
							EA		 BEGIN	SET GW_param2 = 2 END
							GENERAL	 BEGIN	SET GW_param2 = 3 END
							RACE	 BEGIN	SET GW_param2 = 4 END
							CLASS	 BEGIN	SET GW_param2 = 5 END
							SPECIFIC BEGIN	SET GW_param2 = 6 END
							GENDER	 BEGIN	SET GW_param2 = 7 END
							ALIGN	 BEGIN	SET GW_param2 = 8 END
							KIT		 BEGIN	SET GW_param2 = 9 END
							DEFAULT
						END	// of PATCH_MATCH ~%GW_kind%~ WITH
					END		// of PATCH_IF (GW_param1 != "-1")
				END			// of PATCH_IF FILE_EXISTS_IN_GAME ~%GW_kind%.ids~
			END				// of PATCH_IF ("%GW_kind%" STRING_COMPARE_CASE ~NAME~) AND ("%GW_kind%" STRING_COMPARE_CASE ~SCRIPT_NAME~)

		// Actor's name case : If 'IDS File' is set to 10, the item is restricted to characters with the name specified by the strref held in parameter1. TODO If the strref is set to -1 (None), then you are targeting player-created characters (e.g., CHARNAME).
		// -----------------
			PATCH_IF ("%GW_kind%" STRING_COMPARE_CASE ~NAME~ = 0) BEGIN
				SET GW_param2 = 10
				PATCH_IF ("%GW_restrict%" STRING_COMPARE_REGEXP ~^[@#]-?[0-9]+$~ = 0) AND ("GW_restrict%" STR_CMP ~~) BEGIN
					INNER_PATCH_SAVE GWrestrict ~%GW_restrict%~ BEGIN		// Suppression du premier caractère (@ ou #) - Removes 1st character (@ or #).
						REPLACE_TEXTUALLY ~^[@#]~  ~~
					END
					PATCH_IF ("%GW_restrict%" STRING_COMPARE_REGEXP ~^[@]-?[0-9]+$~ = 0) BEGIN
						SET GW_param1 = RESOLVE_STR_REF ((AT %GWrestrict%))
					END ELSE BEGIN
						SET GW_param1 = EVAL "%GWrestrict%"
					END
				END ELSE BEGIN										// Sinon, on va chercher la référence dans le fichier dialog.tlk
					SET GW_param1 = EVAL "%GW_restrict%"
				END
			END		// of PATCH_IF ("%GW_kind%" STRING_COMPARE_CASE ~NAME~ = 0)

		// Actor's scripting name case : If 'IDS File' is set to 11, the item is restricted to characters with the death variable specified by the resource field. TODO If ˜no death variable is specified in the resource field, then you are targeting player-created characters (e.g., CHARNAME).
		// ---------------------------
			PATCH_IF ("%GW_kind%" STRING_COMPARE_CASE ~SCRIPT_NAME~ = 0) BEGIN
				SET GW_param1 = 0
				PATCH_IF (STRING_LENGTH "%GW_restrict%" < 9) BEGIN	// 8 characters maximum in resource field
					SPRINT GW_resource319 EVAL "%GW_restrict%"
					SET GW_param2 = 11
				END
			END		// of PATCH_IF ("%GW_kind%" STRING_COMPARE_CASE ~SCRIPT_NAME~ = 0)

			// Description note.
			// -----------------
			PATCH_IF ("%GW_mess319%" STRING_COMPARE_REGEXP ~^[@#]-?[0-9]+$~ = 0) AND ("%GW_mess319%" STR_CMP ~~) BEGIN
				INNER_PATCH_SAVE GWspecial ~%GW_mess319%~ BEGIN		// Suppression du premier caractère (@ ou #) - Removes 1st character (@ or #).
					REPLACE_TEXTUALLY ~^[@#]~  ~~
				END
				PATCH_IF ("GW_mess319%" STRING_COMPARE_REGEXP ~^[@]-?[0-9]+$~ = 0) BEGIN
					SET GW_special319 = RESOLVE_STR_REF ((AT %GWspecial%))
				END ELSE BEGIN
					SET GW_special319 = EVAL "%GWspecial%"
				END
			END ELSE BEGIN										// Sinon, on va chercher la référence dans le fichier dialog.tlk
				SET GW_special319 = EVAL "%GW_mess319%"
			END

			// Adds Effect #319 Usability: Item Usability if needed.
			// -----------------------------------------------------
			PATCH_IF (GW_param2 > 0) BEGIN
				LPF ~ADD_ITEM_EQEFFECT~ INT_VAR opcode = 319 target = 1 timing = 2 parameter1 = EVAL "%GW_param1%" parameter2 = EVAL "%GW_param2%" power = EVAL "%GW_power%" special = EVAL "%GW_special319%" STR_VAR resource = EVAL "%GW_resource319%" END
			END	// of PATCH_IF (GW_param2 > 0)

		END		// of PATCH_IF ("%GW_restrict%" STR_CMP ~~) AND ("%GW_kind%" STR_CMP ~~)
	END	 		// of PATCH_IF (GW_shaman) BEGIN

END 			// of DEFINE_PATCH_FUNCTION


/* =========================================================================================================================================== *
 *  FUNCTION GW_FIND_DLG_RESPONSE_STRING: LOOKS for state and transition numbers matching a strref in a dialog.                                *
 *                                        RECHERCHE de numéros d'état et de transition correspondant à un strref dans un fichier de dialogue.  *
 * ------------------------------------------------------------------------------------------------------------------------------------------- *
 *  STR_VAR                                                                                                                                    *
 *      - GW_string_dlg        = strref to be found (may be @nn, #nnn or nnn).                                                                 *
 *	RETURNS                                                                                                                                    *
 *      - GW_transition_found  = Check if strref exists in dialog file (Y = Yes - N = No)                                                      *
 *      - GW_state_number      = Dialogue state number matching strref.                                                                        *
 *      - GW_transition_number = Transition number matching strref.                                                                            *
 * =========================================================================================================================================== */

DEFINE_PATCH_FUNCTION ~GW_FIND_DLG_RESPONSE_STRING~
    STR_VAR	GW_string_dlg = 0      // string que l'on cherche
    RET     GW_transition_found	   // Variable indiquant que l'on a trouvé une correspondance ==> Y = strref found
            GW_state_number        // Numéro du dialogue
            GW_transition_number   // Numéro de la transition (réponse)
BEGIN

	PATCH_IF ("%GW_string_dlg%" STR_CMP ~~) OR (GW_string_dlg >= 0) BEGIN

		PATCH_IF ("%GW_string_dlg%" STRING_COMPARE_REGEXP ~^[@#]-?[0-9]+$~ = 0) BEGIN
			INNER_PATCH_SAVE GW_strref ~%GW_string_dlg%~ BEGIN		// Suppression du premier caractère (@ ou #) - Removes 1st character (@ or #).
				REPLACE_TEXTUALLY ~^[@#]~  ~~
			END
			PATCH_IF ("%GW_string_dlg%" STRING_COMPARE_REGEXP ~^[@]-?[0-9]+$~ = 0) BEGIN
				SET GW_string_dlg = RESOLVE_STR_REF ((AT %GW_strref%))
			END
		END

		SET GW_transition_number = "-99"
		SET GW_state_number = "-99"
		SPRINT GW_transition_found "N"
		READ_LONG 0x08 GW_numstates             // Number of states
		READ_LONG 0x0c GW_offstates             // Offset of state table from start of file
		READ_LONG 0x10 GW_numresponse           // Number of transitions
		READ_LONG 0x14 GW_offresponse           // Offset of transition table from start of file
/*	LISTED but NOT USED
		READ_LONG 0x18 GW_offstatetrigger       // Offset of state trigger table from start of file
		READ_LONG 0x1c GW_numstatetrigger       // Number of state triggers
		READ_LONG 0x20 GW_offresponsetrigger    // Offset of transition trigger table from start of file
		READ_LONG 0x24 GW_numresponsetrigger    // Number of transition triggers
		READ_LONG 0x28 GW_offaction             // Offset of action table from start of file
		READ_LONG 0x2c GW_numaction             // Number of actions*/
//		PATCH_PRINT ~CONTROL GW_FIND_DLG_RESPONSE_STRING : %SOURCE_RES%  -  %GW_numstates% States at offset %GW_offstates%  -  %GW_numresponse% Responses  at offset %GW_offresponse%.~

		FOR (state = 0 ; state < GW_numstates ; ++state) BEGIN

			PATCH_IF ("%GW_transition_found%" STR_CMP "Y") BEGIN
				READ_LONG ("%GW_offstates%" +       (state * 0x10)) GW_state_string         // Actor response text (i.e. what the non-player character says to the party)
				READ_LONG ("%GW_offstates%" + 0x4 + (state * 0x10)) GW_index_first_response // Index of the first transition corresponding to this state (i.e. the index in the transition table of the first potential response the party can make in this state)
				READ_LONG ("%GW_offstates%" + 0x8 + (state * 0x10)) GW_state_num_response   // Number of transitions corresponding to this state (i.e. how many possible responses are there to this state). A consecutive range of transitions in the transition table are assigned to this state, starting from 'first', as given by the previous field, ranging up to (but not including) 'first'+'count'.
//				PATCH_PRINT ~	CONTROL FUNCTION GW_FIND_DLG_RESPONSE_STRING : %SOURCE_RES%  -  State #%state% = %GW_state_string%	-  Nb responses = %GW_state_num_response%  -  Index 1° réponse = %GW_index_first_response%.~

				FOR (response = 0 ; response < GW_state_num_response ; ++response) BEGIN
					READ_LONG ("%GW_offresponse%" + 0x4 + ("%GW_index_first_response%" * 0x20) + (response * 0x20)) GW_response_string

					PATCH_IF (GW_response_string = GW_string_dlg) BEGIN
						SET GW_transition_number = response
						SET GW_state_number = state
						SPRINT GW_transition_found "Y"
//						PATCH_PRINT ~	CONTROL FUNCTION GW_FIND_DLG_RESPONSE_STRING : %SOURCE_RES%  - State #%state% = %GW_state_string%  -  Response #%response% = %GW_response_string%.~
					END

				END // of Looping through responses

			END // PATCH_IF ("%GW_transition_found%" STRING_COMPARE_CASE "Y")

		END // of Looping through states

	END	// of PATCH_IF ("%GW_string_dlg%" STR_CMP ~~) OR (GW_string_dlg >= 0) BEGIN
	
END // of DEFINE_PATCH_FUNCTION

/* ================================================================================================================================================================= *
 *  Concept borrowed from Sam's BAM Batcher mod v2.4.2 to convert inventory BAMs to EE games. From Gwendolyne's original code, modified by Sam.                      *
 *  Code emprunté au mod BAM Batcher v2.4.2 de Sam pour convertir les fichiers BAM d'inventaire au format EE. D'après un code original de Gwendolyne.                *
 *                                                                                                                                                                   *
 *  Source: https://www.gibberlings3.net/forums/topic/28823-merchant-mods/?do=findComment&comment=254149                                                             *
 *                                                                                                                                                                   *
 * ================================================================================================================================================================= *
 *  This function attempts to modify traditional inventory BAMs so that both the large and small icons are utilized by the EE games. The inventory BAM files must    *
 *  have two sequences, the first containing the "large" inventory icon frame and the second containing the "small" inventory icon frame to be processed.            *
 *  Inventory icon BAMs in the /bam folder that meet these requirements are patched and saved back to the override folder.                                           *
 * ----------------------------------------------------------------------------------------------------------------------------------------------------------------- *
 *  Cette fonction permet de modifier les fichiers BAM d'icônes d'inventaire afin que les jeux améliorés (EE) affichent à la fois leurs grandes et leurs petites     *
 *  icônes. Ces fichiers comportent deux séquences, la première représentant la grande icône et la seconde la petite. Les fichiers BAM du répertoire /bam répondant  *
 *  à ces caractéristiques sont modifiés et sauvegardés dans le répertoire override.                                                                                 *
 * ================================================================================================================================================================= */

DEFINE_PATCH_FUNCTION ~gw_convert_inventory_bam_to_ee~ BEGIN

// Read BAM
// ---------
    READ_ASCII 0x0 sg (4)    // Signature
    READ_ASCII 0x0 sn (3)    // Short signature

// Decompress if needed.
// ---------------------
    PATCH_IF (~%sg%~ STRING_EQUAL_CASE ~BAMC~ = 1) BEGIN
        READ_LONG 0x8 dl                // Uncompressed data length
        DECOMPRESS_INTO_VAR 0xc (SOURCE_SIZE - 0xc) dl contents
    END ELSE BEGIN
        dl = SOURCE_SIZE                // Uncompressed data length
		READ_ASCII 0 contents (dl)
    END
	SET proceed = 0
	INNER_PATCH_SAVE contents "%contents%" BEGIN

// Add "small" frame as second frame in the first sequence.
// --------------------------------------------------------
		PATCH_IF (~%sn%~ STRING_EQUAL_CASE ~BAM~ = 1) BEGIN
			READ_BYTE    0x0a cc                               // Count of cycles
			READ_SHORT   0x08 fc                               // Frame count
			READ_LONG    0x0c fn                               // Frame entry offset
			READ_LONG    0x14 lu                               // Offset (from start of file) to frame lookup table
			READ_SHORT   (fn + (fc * 0xc)) c_fcc0              // Count of frame indices in 0th cycle
			PATCH_IF (cc = 2) AND (c_fcc0 = 1) BEGIN           // only 2 cycles = inventory bam (ground and description have 1 or 4 frames).  only 1 frame in 0th cycle = not already processed
				READ_SHORT   (fn + (fc * 0xc) + 0x2) c_fic0    // Index into frame lookup table of first frame index in 0th cycle
				READ_SHORT   (fn + (fc * 0xc) + 0x4) c_fcc1    // Count of frame indices in 1st cycle
				READ_SHORT   (fn + (fc * 0xc) + 0x6) c_fic1    // Index into frame lookup table of first frame index in 1st cycle
				PATCH_IF (c_fcc1>=1) BEGIN                     // 1st cycle mush have at least 1 frame in order to add a frame to 0th cycle
					READ_BYTE    (lu + c_fic0) FLT_0           // Get frame used by cycle 0
					READ_BYTE    (lu + c_fic1) FLT_1           // Get frame used by cycle 1
					SET proceed = 1
					WRITE_SHORT  (fn + (fc * 0xc)) 2           // Sets 0th cycle to have 2 frames
					WRITE_SHORT  (fn + (fc * 0xc) + 0x2) 0     // Sets 0th cycle to start at FLT index 0
					WRITE_BYTE   (lu) FLT_0                    // Sets 0th FLT entry to the frame used by cycle 0
					WRITE_BYTE   (lu + 1) FLT_1                // Sets 1st FLT entry to the frame used by cycle 1
				END
			END
		END

// Recompress if needed.
// ---------------------
		PATCH_IF (~%sg%~ STRING_EQUAL_CASE ~BAMC~ = 1) AND (proceed = 1) BEGIN
			COMPRESS_REPLACE_FILE 0 dl 9
			INSERT_BYTES 0x0 0xc
			WRITE_ASCII 0x0 ~BAMCV1  ~
			WRITE_LONG 0x8 dl
			dl += 0xc				// Compressed data length
		END
    END
	PATCH_IF (proceed = 1) BEGIN
		PATCH_IF (SOURCE_SIZE > dl) BEGIN
			DELETE_BYTES 0 (SOURCE_SIZE - dl)
		END ELSE PATCH_IF (SOURCE_SIZE < dl) BEGIN
			INSERT_BYTES 0 (dl - SOURCE_SIZE)
		END
		WRITE_ASCIIE 0 "%contents%"
	END

END    // of DEFINE_PATCH_FUNCTION
